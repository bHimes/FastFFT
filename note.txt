The previous approach to handling the twiddle factors was to:

- pass in Q as a runtime arg
- have a FFT::storage size array of twiddle factors called twiddle_factor_args, where this is normally equal ept ~ 8 complex values = 16 registers
- when loading the data, using the size of the FFT = P to calculate
    - exp(-i2pi/(P*Q=N)) * index (index = n of the input sequence)
- When doing the first FFT, there is no mul b/c this is WN^k=0 = 1
- For each subsequent subFFT 1 ... Q, 
    - reload the realvalued thread data
    - calculate TD * exp(i * ( TF * subFFT))
    

- This can be improved 2 ways 
    - if we label twiddle_factor_args[0] = exp(aj) where j = index
        - index is incremented by FFT::stride => S
        - twiddle_factor_args[1] = exp(a(j+s)) = exp(aj)exp(as)
        - twiddle_factor_args[2] = exp(a(j+2s))= exp(aj)exp(a2s) = exp(aj)exp(as)exp(as)
        - so if instead of saving 8 float twiddle_factor_args, we can instead calculate 1 extra complex floats
            - then each iteration we for i > 0 we just multiply by exp(as)
            - this reduces the register count by 6 floats (6 registers) per thread
            - this also reduces the instruction count
        - Testing the absolute difference between methods compared to double precision
            - This is assuming 64 ept for a 512 sequence, far more than we'll ever use in order to make the new approach as bad as it can be by accumulating error 
                - To me these are effectively the same error
            - avg diff old = -6.41448e-08 -1.47702e-08
            - avg diff new = 3.05154e-08 -6.6284e-08
        - sincosf max error 2 ulps
        - powf max error 4 ulps - also composed of exp2f and a log2f and a sum, so it is actually slower than sincosf
        - Because we always have an angle < 2pi, (2pi/N*k where k <=N) we always use the fast path on the GPU